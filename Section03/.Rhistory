return(c(beta_hat, R, R_uc, R_adj, AIC, SIC, R, R_adj))
}
else{
# Convert y_data to matrices
y_data <- as.matrix(y_data)
# Add a column of ones to X_data (could also just make new df var manually)
X_data <- mutate_(X_data, "ones" = 1)
# Move the intercept column to the front (this is cool)
X_data <- select_(X_data, "ones", .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
rownames(beta_hat) <- c("intercept", X)
y_hat<-X_data%*%beta_hat #Predicted values
SST<-sum((y_data)^2) #Total sum of squares
SST_demean <- sum((y_hat - mean(y_data))^2)
SSM<-sum((y_hat)^2) #Regression sum of squares
SSR<-sum((y_data-y_hat)^2) #Error sum of squares
n <- dim(X_data)[1]
k <- dim(X_data)[2]
dof <- n - k
R_uc <- 1 - (SSR/SST)
R <- 1-(SSR/SST_demean)
R_adj <- 1 - (1 - R) * ((n-1)/(n-k))
AIC <- log(SSR/n) + (2*k)/n
SIC <- log(SSR/n) + (k/n) * log(n)
sv <- SSR/(n-k)
assign("y_hat", y_hat, .GlobalEnv)
# Return beta_hat
return(c(beta_hat, R, R_uc, R_adj,  AIC, SIC))
}
}
summary(lm(wb_data$CO2pc ~ wb_data$GDPpc +0))$adj.r.squared
Q15<-b_ols(data = wb_data, y="CO2pc", X=c("GDPpc"))
R_uc<-Q15[3]
R_adj<-Q15[4]
R<-Q15[2]
AIC<-Q15[5]
SIC<-Q15[6]
sv<-Q15[7]
R
R_uc
# OLS function ----------------------------------------------------------------
b_ols <- function(data, y, X, intercept=NULL) {
# This function takes as inputs:
# 1. A data fram ('data)
# 2. A dependent variable, y
# 3. A list of X variables c("x1", "x2", ...)
# 4. An optional 4th argument, T, to include an intercept
require(dplyr)
# Select y variable data from 'data'
y_data <- subset(data, select=c(y))
# Select X variable data from 'data'
X_data <- select_(data, .dots = X)
if(is.null(intercept)) {
# Convert y_data to matrices
y_data <- as.matrix(y_data)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
y_hat<-X_data%*%beta_hat #Predicted values
SST<-sum((y_data)^2) #Total sum of squares
SSM_demean <- sum((y_hat - mean(y_data))^2)
SST_demean <- sum((y_data - mean(y_data))^2)
SSM<-sum((y_hat)^2) #Regression sum of squares
SSR<-sum((y_data-y_hat)^2) #Error sum of squares
n <- dim(X_data)[1]
k <- dim(X_data)[2]
dof <- n - k
R_uc <- 1 - (SSR/SST)
R <- SSM_demean/SST_demean
R_adj <- 1 - (1 - R) * ((n-1)/(n-k))
AIC <- log(SSR/n) + (2*k)/n
SIC <- log(SSR/n) + (k/n) * log(n)
assign("y_hat", y_hat, .GlobalEnv)
# Return beta_hat
return(c(beta_hat, R, R_uc, R_adj, AIC, SIC, R, R_adj))
}
else{
# Convert y_data to matrices
y_data <- as.matrix(y_data)
# Add a column of ones to X_data (could also just make new df var manually)
X_data <- mutate_(X_data, "ones" = 1)
# Move the intercept column to the front (this is cool)
X_data <- select_(X_data, "ones", .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
rownames(beta_hat) <- c("intercept", X)
y_hat<-X_data%*%beta_hat #Predicted values
SST<-sum((y_data)^2) #Total sum of squares
SSM_demean <- sum((y_hat - mean(y_data))^2)
SST_demean <- sum((y_data - mean(y_data))^2)
SSM<-sum((y_hat)^2) #Regression sum of squares
SSR<-sum((y_data-y_hat)^2) #Error sum of squares
n <- dim(X_data)[1]
k <- dim(X_data)[2]
dof <- n - k
R_uc <- 1 - (SSR/SST)
R <- SSM_demean/SST_demean
R_adj <- 1 - (1 - R) * ((n-1)/(n-k))
AIC <- log(SSR/n) + (2*k)/n
SIC <- log(SSR/n) + (k/n) * log(n)
sv <- SSR/(n-k)
assign("y_hat", y_hat, .GlobalEnv)
# Return beta_hat
return(c(beta_hat, R, R_uc, R_adj,  AIC, SIC))
}
}
summary(lm(wb_data$CO2pc ~ wb_data$GDPpc +0))$adj.r.squared
b_ols(data = wb_data, y="CO2pc", X=c("GDPpc"))
R_uc<-Q15[3]
R_adj<-Q15[4]
R<-Q15[2]
AIC<-Q15[5]
SIC<-Q15[6]
sv<-Q15[7]
# OLS function ----------------------------------------------------------------
b_ols <- function(data, y, X, intercept=NULL) {
# This function takes as inputs:
# 1. A data fram ('data)
# 2. A dependent variable, y
# 3. A list of X variables c("x1", "x2", ...)
# 4. An optional 4th argument, T, to include an intercept
require(dplyr)
# Select y variable data from 'data'
y_data <- subset(data, select=c(y))
# Select X variable data from 'data'
X_data <- select_(data, .dots = X)
if(is.null(intercept)) {
# Convert y_data to matrices
y_data <- as.matrix(y_data)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
y_hat<-X_data%*%beta_hat #Predicted values
SST<-sum((y_data)^2) #Total sum of squares
SSM_demean <- sum(((y_hat - mean(y_data))^2))
print(SSM_demean)
SST_demean <- sum((y_data - mean(y_data))^2)
print(SST_demean)
SSM<-sum((y_hat)^2) #Regression sum of squares
SSR<-sum((y_data-y_hat)^2) #Error sum of squares
n <- dim(X_data)[1]
k <- dim(X_data)[2]
dof <- n - k
R_uc <- 1 - (SSR/SST)
R <- SSM_demean/SST_demean
R_adj <- 1 - (1 - R) * ((n-1)/(n-k))
AIC <- log(SSR/n) + (2*k)/n
SIC <- log(SSR/n) + (k/n) * log(n)
assign("y_hat", y_hat, .GlobalEnv)
# Return beta_hat
return(c(beta_hat, R, R_uc, R_adj, AIC, SIC, R, R_adj))
}
else{
# Convert y_data to matrices
y_data <- as.matrix(y_data)
# Add a column of ones to X_data (could also just make new df var manually)
X_data <- mutate_(X_data, "ones" = 1)
# Move the intercept column to the front (this is cool)
X_data <- select_(X_data, "ones", .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
rownames(beta_hat) <- c("intercept", X)
y_hat<-X_data%*%beta_hat #Predicted values
SST<-sum((y_data)^2) #Total sum of squares
SSM_demean <- sum((y_hat - mean(y_data))^2)
SST_demean <- sum((y_data - mean(y_data))^2)
SSM<-sum((y_hat)^2) #Regression sum of squares
SSR<-sum((y_data-y_hat)^2) #Error sum of squares
n <- dim(X_data)[1]
k <- dim(X_data)[2]
dof <- n - k
R_uc <- 1 - (SSR/SST)
R <- SSM_demean/SST_demean
R_adj <- 1 - (1 - R) * ((n-1)/(n-k))
AIC <- log(SSR/n) + (2*k)/n
SIC <- log(SSR/n) + (k/n) * log(n)
sv <- SSR/(n-k)
assign("y_hat", y_hat, .GlobalEnv)
# Return beta_hat
return(c(beta_hat, R, R_uc, R_adj,  AIC, SIC))
}
}
summary(lm(wb_data$CO2pc ~ wb_data$GDPpc +0))$adj.r.squared
b_ols(data = wb_data, y="CO2pc", X=c("GDPpc"))
Q15<-b_ols(data = wb_data, y="CO2pc", X=c("GDPpc"))
R_uc<-Q15[3]
R_adj<-Q15[4]
R<-Q15[2]
AIC<-Q15[5]
SIC<-Q15[6]
sv<-Q15[7]
b_ols <- function(data, y, X, intercept=NULL) {
# This function takes as inputs:
# 1. A data fram ('data)
# 2. A dependent variable, y
# 3. A list of X variables c("x1", "x2", ...)
# 4. An optional 4th argument, T, to include an intercept
require(dplyr)
# Select y variable data from 'data'
y_data <- subset(data, select=c(y))
# Select X variable data from 'data'
X_data <- select_(data, .dots = X)
if(is.null(intercept)) {
# Convert y_data to matrices
y_data <- as.matrix(y_data)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
}
else{
# Convert y_data to matrices
y_data <- as.matrix(y_data)
# Add a column of ones to X_data (could also just make new df var manually)
X_data <- mutate_(X_data, "ones" = 1)
# Move the intercept column to the front (this is cool)
X_data <- select_(X_data, "ones", .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
rownames(beta_hat) <- c("intercept", X)
}
y_hat<-X_data%*%beta_hat #Predicted values
SST<-sum((y_data)^2) #Total sum of squares
SSM_demean <- sum(((y_hat - mean(y_data))^2))
print(SSM_demean)
SST_demean <- sum((y_data - mean(y_data))^2)
print(SST_demean)
SSM<-sum((y_hat)^2) #Regression sum of squares
SSR<-sum((y_data-y_hat)^2) #Error sum of squares
n <- dim(X_data)[1]
k <- dim(X_data)[2]
dof <- n - k
R_uc <- 1 - (SSR/SST)
R <- SSM_demean/SST_demean
R_adj <- 1 - (1 - R) * ((n-1)/(n-k))
AIC <- log(SSR/n) + (2*k)/n
SIC <- log(SSR/n) + (k/n) * log(n)
assign("y_hat", y_hat, .GlobalEnv)
# Return beta_hat
return(c(beta_hat, R, R_uc, R_adj, AIC, SIC, R, R_adj))
}
summary(lm(wb_data$CO2pc ~ wb_data$GDPpc +0))$adj.r.squared
Q15<-b_ols(data = wb_data, y="CO2pc", X=c("GDPpc"))
#R-squared
# output: beta_hat, R, R_uc, R_adj,  AIC, SIC, sv
R_uc<-Q15[3]
R_adj<-Q15[4]
R<-Q15[2]
AIC<-Q15[5]
SIC<-Q15[6]
sv<-Q15[7]
Q15<-b_ols(data = wb_data, y="CO2pc", X=c("GDPpc"), T)
summary(lm(wb_data$CO2pc ~ wb_data$GDPpc +0))$adj.r.squared
Q15<-b_ols(data = wb_data, y="CO2pc", X=c("GDPpc"), T)
#R-squared
# output: beta_hat, R, R_uc, R_adj,  AIC, SIC, sv
R_uc<-Q15[3]
R_adj<-Q15[4]
R<-Q15[2]
AIC<-Q15[5]
SIC<-Q15[6]
sv<-Q15[7]
# OLS function ----------------------------------------------------------------
b_ols <- function(data, y, X, intercept=NULL) {
# This function takes as inputs:
# 1. A data fram ('data)
# 2. A dependent variable, y
# 3. A list of X variables c("x1", "x2", ...)
# 4. An optional 4th argument, T, to include an intercept
require(dplyr)
# Select y variable data from 'data'
y_data <- subset(data, select=c(y))
# Select X variable data from 'data'
X_data <- select_(data, .dots = X)
if(is.null(intercept)) {
# Convert y_data to matrices
y_data <- as.matrix(y_data)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
}
else{
# Convert y_data to matrices
y_data <- as.matrix(y_data)
# Add a column of ones to X_data (could also just make new df var manually)
X_data <- mutate_(X_data, "ones" = 1)
# Move the intercept column to the front (this is cool)
X_data <- select_(X_data, "ones", .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
rownames(beta_hat) <- c("intercept", X)
}
y_hat<-X_data%*%beta_hat #Predicted values
SST<-sum((y_data)^2) #Total sum of squares
SSM<-sum((y_hat)^2) #Regression sum of squares
SSR<-sum((y_data-y_hat)^2) #Error sum of squares
SSM_demean <- sum((y_hat - mean(y_data))^2)
SST_demean <- sum((y_data - mean(y_data))^2)
n <- dim(X_data)[1]
k <- dim(X_data)[2]
dof <- n - k
R_uc <- 1 - (SSR/SST)
R <- SSM_demean/SST_demean
R_adj <- 1 - (1 - R) * ((n-1)/(n-k))
AIC <- log(SSR/n) + (2*k)/n
SIC <- log(SSR/n) + (k/n) * log(n)
assign("y_hat", y_hat, .GlobalEnv)
# Return beta_hat
return(c(beta_hat, R, R_uc, R_adj, AIC, SIC, R, R_adj))
}
Q15<-b_ols(data = wb_data, y="CO2pc", X=c("GDPpc"), T)
R_uc<-Q15[3]
R_adj<-Q15[4]
R<-Q15[2]
AIC<-Q15[5]
SIC<-Q15[6]
sv<-Q15[7]
b_ols(data = wb_data, y="CO2pc", X=c("GDPpc"), T)
b_ols(data = wb_data, y="CO2pc", X=c("GDPpc"))
b_ols <- function(data, y, X, intercept=NULL) {
# This function takes as inputs:
# 1. A data fram ('data)
# 2. A dependent variable, y
# 3. A list of X variables c("x1", "x2", ...)
# 4. An optional 4th argument, T, to include an intercept
require(dplyr)
# Select y variable data from 'data'
y_data <- subset(data, select=c(y))
# Select X variable data from 'data'
X_data <- select_(data, .dots = X)
if(is.null(intercept)) {
# Convert y_data to matrices
y_data <- as.matrix(y_data)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
}
else{
# Convert y_data to matrices
y_data <- as.matrix(y_data)
# Add a column of ones to X_data (could also just make new df var manually)
X_data <- mutate_(X_data, "ones" = 1)
# Move the intercept column to the front (this is cool)
X_data <- select_(X_data, "ones", .dots = X)
# Convert X_data to matrices
X_data <- as.matrix(X_data)
# Calculate beta hat
beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
# Change the name of 'ones' to 'intercept'
rownames(beta_hat) <- c("intercept", X)
}
y_hat<-X_data%*%beta_hat #Predicted values
SST<-sum((y_data)^2) #Total sum of squares
SSM<-sum((y_hat)^2) #Regression sum of squares
SSR<-sum((y_data-y_hat)^2) #Error sum of squares
SSM_demean <- sum((y_hat - mean(y_data))^2)
SST_demean <- sum((y_data - mean(y_data))^2)
print(SSM_demean)
print(SST_demean)
n <- dim(X_data)[1]
k <- dim(X_data)[2]
dof <- n - k
R_uc <- 1 - (SSR/SST)
R <- SSM_demean/SST_demean
R_adj <- 1 - (1 - R) * ((n-1)/(n-k))
AIC <- log(SSR/n) + (2*k)/n
SIC <- log(SSR/n) + (k/n) * log(n)
assign("y_hat", y_hat, .GlobalEnv)
# Return beta_hat
return(c(beta_hat, R, R_uc, R_adj, AIC, SIC, R, R_adj))
}
Q15<-b_ols(data = wb_data, y="CO2pc", X=c("GDPpc"), T)
#R-squared
# output: beta_hat, R, R_uc, R_adj,  AIC, SIC, sv
R_uc<-Q15[3]
R_adj<-Q15[4]
R<-Q15[2]
AIC<-Q15[5]
SIC<-Q15[6]
sv<-Q15[7]
b_ols(data = wb_data, y="CO2pc", X=c("GDPpc"), T)
summary(lm(wb_data$CO2pc ~ wb_data$GDPpc +0))$r.squared
summary(lm(wb_data$CO2pc ~ wb_data$GDPpc))$r.squared
b_ols(data = wb_data, y="CO2pc", X=c("GDPpc"))
x<-data.frame(wb_data$GDPpc)
x$intcp <- 1
x<-data.matrix(x)
y<-wb_data$CO2pc
b<-solve((t(x)%*%x))%*%t(x)%*%y
#lm(y~wb_data$GDPpc) #test
#summary(lm(y~x +0))
wb_data$y_pred<-x%*%b #Predicted values
wb_data$residual <- y-wb_data$y_pred
fit() #calculates our measures of fit
#Compare the regression line with and without intercept
CO2_GDP_pc <- CO2_GDP_pc + geom_abline(slope = b[1], intercept = b[2], color = "red") + geom_abline(slope = b1[1], color = "blue")
CO2_GDP_pc
summary(lm(wb_data$CO2pc ~ wb_data$GDPpc +0))$adj.r.squared
Q15<-b_ols(data = wb_data, y="CO2pc", X=c("GDPpc"), T)
#R-squared
# output: beta_hat, R, R_uc, R_adj,  AIC, SIC, sv
R_uc<-Q15[4]
R_adj<-Q15[5]
R<-Q15[3]
AIC<-Q15[6]
SIC<-Q15[7]
sv<-Q15[8]
#Compare the regression line with and without intercept
CO2_GDP_pc <- CO2_GDP_pc + geom_abline(slope = b[1], intercept = b[2], color = "red") + geom_abline(slope = b1[1], color = "blue")
CO2_GDP_pc
wb_data$y_hat<-y_hat
wb_data$residual<-wb_data$CO2pc - wb_data$y_hat
#Compare the regression line with and without intercept
CO2_GDP_pc <- CO2_GDP_pc + geom_abline(slope = b[1], intercept = b[2], color = "red") + geom_abline(slope = b1[1], color = "blue")
CO2_GDP_pc
#Plot of predicted value vs co2pc
scatter_predict_co2<-ggplot(wb_data, aes(x=y_pred, y=CO2pc)) +
geom_point(size=2, shape=19, color="darkblue", alpha=0.3)+
#ggtitle(expression(Log~of~Per-Capita~CO[2]~Emissions~vs.~Log~of~Per-Capita~GDP~"(Demeaned)")) +
labs(
x= "Predicted values",
y= "Per-Capita CO2",
caption = "Note: Per-Capita GDP is in 2010 U.S. Dollars."
) + mytheme
scatter_predict_co2
#Plot of residuals vs gdppc
scatter_residuals_gdppc<-ggplot(wb_data, aes(y=residual, x=GDPpc)) +
geom_point(size=2, shape=19, color="darkblue", alpha=0.3)+
#ggtitle(expression(Log~of~Per-Capita~CO[2]~Emissions~vs.~Log~of~Per-Capita~GDP~"(Demeaned)")) +
labs(
x= "Per-Capita GDP",
y= "residuals",
caption = "Note: Per-Capita GDP is in 2010 U.S. Dollars."
) + mytheme + geom_hline(yintercept=0, linetype = "longdash", col = "red")
scatter_residuals_gdppc
wb_data$GDPpc2 <- wb_data$GDPpc ** 2
Q15<-b_ols(data = wb_data, y="CO2pc", X=c("GDPpc", "GDPpc2"))
lm(wb_data$CO2pc~wb_data$GDPpc + wb_data$GDPpc2) #test
wb_data$GDPpc2 <- wb_data$GDPpc ** 2
Q15<-b_ols(data = wb_data, y="CO2pc", X=c("GDPpc", "GDPpc2"), T)
lm(wb_data$CO2pc~wb_data$GDPpc + wb_data$GDPpc2) #test
Q17<-b_ols(data = wb_data, y="CO2pc", X=c("GDPpc", "GDPpc2"), T)
lm(wb_data$CO2pc~wb_data$GDPpc + wb_data$GDPpc2) #test
R_uc<-Q17[4]
R_adj<-Q17[5]
R<-Q17[3]
AIC<-Q17[6]
SIC<-Q17[7]
sv<-Q17[8]
Q17
R_uc<-Q17[5]
R_adj<-Q17[6]
R<-Q17[4]
AIC<-Q17[7]
SIC<-Q17[8]
sv<-Q17[9]
wb_data$y_hat<-y_hat
wb_data$residual<-wb_data$CO2pc - wb_data$y_hat
#Plot of predicted value vs co2pc
scatter_predict_co2<-ggplot(wb_data, aes(x=y_pred, y=CO2pc)) +
geom_point(size=2, shape=19, color="darkblue", alpha=0.3)+
#ggtitle(expression(Log~of~Per-Capita~CO[2]~Emissions~vs.~Log~of~Per-Capita~GDP~"(Demeaned)")) +
labs(
x= "Predicted values",
y= "Per-Capita CO2",
caption = "Note: Per-Capita GDP is in 2010 U.S. Dollars."
) + mytheme
scatter_predict_co2
#Plot of residuals vs gdppc
scatter_residuals_gdppc2<-ggplot(wb_data, aes(y=residual, x=GDPpc)) +
geom_point(size=2, shape=19, color="darkblue", alpha=0.3)+
#ggtitle(expression(Log~of~Per-Capita~CO[2]~Emissions~vs.~Log~of~Per-Capita~GDP~"(Demeaned)")) +
labs(
x= "Per-Capita GDP",
y= "residuals",
caption = "Note: Per-Capita GDP is in 2010 U.S. Dollars."
) + mytheme + geom_hline(yintercept=0, linetype = "longdash", col = "red")
scatter_residuals_gdppc2
wb_data$GDPpc2dev<-wb_data$GDPpc2-mean(wb_data$GDPpc2)
df<-select(wb_data, GDPpcdev, GDPpc2dev)
df$intercept <- "1"
x<-as.matrix(sapply(df, as.numeric))
y<-wb_data$CO2pcdev
b<-solve(t(x)%*%x, tol = 1e-20)%*%t(x)%*%y
lm(wb_data$CO2pcdev~wb_data$GDPpcdev + wb_data$GDPpc2dev) #test
wb_data$GDPpc2dev<-wb_data$GDPpc2-mean(wb_data$GDPpc2)
Q17<-b_ols(data = wb_data, y="CO2pcdev", X=c("GDPpcdev"), T)
lm(wb_data$CO2pcdev~wb_data$GDPpcdev + wb_data$GDPpc2dev) #test
Q17
wb_data$GDPpc2dev<-wb_data$GDPpc2-mean(wb_data$GDPpc2)
Q17<-b_ols(data = wb_data, y="CO2pcdev", X=c("GDPpcdev"), T)
Q17
